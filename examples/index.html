<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - loaders - GCode loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<!-- <div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - GCode loader
		</div> -->

		<div id="overlay" style="position: absolute; color: white; font-weight: bold; padding: 4px; background: rgba(0, 0, 0, 0.5); border-radius: 4px; display: inline-block; white-space: nowrap; font-size: 14px;">
			Layer: <span id="layerNumber">0</span>
		</div>			

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { GCodeLoader } from 'three/addons/loaders/GCodeLoader.js';

			let camera, scene, renderer, currentHoverLayer, loadedObject, clickedLayer;

			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();

			
			init();
			// render();
			animate();
			
			window.addEventListener('mousemove', onMouseMove, false);
			// window.addEventListener('click', onClick, false);

			window.addEventListener('contextmenu', function(event) {
				event.preventDefault(); // Prevent the default right-click context menu

				// Use raycaster to check if the right-click is on empty space
				raycaster.setFromCamera(mouse, camera);
				const intersects = raycaster.intersectObjects(scene.children, true);

				if (intersects.length === 0 || !intersects[0].object.name.startsWith('layer')) {
					// Show all layers again if the right-click is not on a layer
					scene.traverse((child) => {
						if (child.name.startsWith('layer')) {
							child.visible = true;
						}
					});
					clickedLayer = null; // Reset the clicked layer variable
				}
			}, false);

			window.addEventListener('click', function(event) {
				// Preventing the event from interfering with the right-click logic
				event.preventDefault();

				// Similar raycasting logic to determine if a layer is clicked
				raycaster.setFromCamera(mouse, camera);
				const intersects = raycaster.intersectObjects(scene.children, true);

				if (intersects.length > 0 && intersects[0].object.name.startsWith('layer')) {
					const intersectedObject = intersects[0].object;
					// Hide all other layers except the clicked one
					scene.traverse((child) => {
						if (child.name.startsWith('layer') && child !== intersectedObject) {
							child.visible = false;
						}
					});
					clickedLayer = intersectedObject; // Store the clicked layer
				}
			}, false);

			function onMouseMove(event) {
				event.preventDefault();
				
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

				raycaster.setFromCamera(mouse, camera);
				const intersects = raycaster.intersectObjects(scene.children, true);

				const overlay = document.getElementById('overlay');
				if (intersects.length > 0) {
					const intersectedObject = intersects[0].object;

					// Assuming each layer object has a name property in 'layerX' format
					const layerName = intersectedObject.name;
					if (layerName.startsWith('layer')) {
						document.getElementById('layerNumber').textContent = layerName.replace('layer', ''); // Assuming layer naming convention is 'layerX'
						overlay.style.display = 'block';
						overlay.style.left = (event.clientX + 10) + 'px'; // Offset by 10px to avoid cursor overlap
						overlay.style.top = (event.clientY + 10) + 'px';
					}
				} else {
					overlay.style.display = 'none';
				}
			}

			// function onClick(event) {
			// 	// Reuse the raycaster setup from the mouse hover feature
			// 	raycaster.setFromCamera(mouse, camera);
			// 	const intersects = raycaster.intersectObjects(scene.children, true);

			// 	if (intersects.length > 0) {
			// 		const intersectedObject = intersects[0].object;

			// 		if (intersectedObject.name.startsWith('layer')) {
			// 			// Hide all other layers except the clicked one
			// 			scene.traverse((child) => {
			// 				if (child.name.startsWith('layer') && child !== intersectedObject) {
			// 					child.visible = false;
			// 				}
			// 			});
			// 			clickedLayer = intersectedObject; // Store the clicked layer
			// 		}
			// 	} else {
			// 		// If clicked on empty space and there was a previously clicked layer
			// 		if (clickedLayer) {
			// 			// Show all layers again
			// 			scene.traverse((child) => {
			// 				if (child.name.startsWith('layer')) {
			// 					child.visible = true;
			// 				}
			// 			});
			// 			clickedLayer = null; // Reset the clicked layer
			// 		}
			// 	}
			// }
			
			function init() {
				camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
				camera.position.set(0, 0, 70);

				scene = new THREE.Scene();

				const loader = new GCodeLoader();
				// loader.load('models/gcode/bub.gcode', function (object) {
				loader.load('models/gcode/benchy_wall.gcode', function (object) {

					object.position.set(-100, -20, 100);
					
					scene.add(object);

					loadedObject = object;

					console.log('GCode model loaded', object);
					// render();
				});

				// Check for WebGL 2 support and create a WebGL 2 context for the renderer
				const canvas = document.createElement('canvas');
				const context = canvas.getContext('webgl2', { alpha: false });

				renderer = new THREE.WebGLRenderer({ canvas: canvas, context: context, antialias: true });
				if (!renderer.capabilities.isWebGL2) {
					console.warn('WebGL 2 is not available. Falling back to WebGL 1.');
				}

				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				const controls = new OrbitControls(camera, renderer.domElement);
				controls.addEventListener('change', render); // use if there is no animation loop
				controls.minDistance = 10;
				controls.maxDistance = 100;

				window.addEventListener('resize', resize);
			}


			function resize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				render();

			}

			function animate() {
				requestAnimationFrame(animate);

				// Update the raycaster based on the camera and mouse position
				performRaycasting();

				if (loadedObject) {
					// loadedObject.rotation.z += 0.001; // Adjust rotation speed as needed
					// object.geometry.center();
				}

				renderer.render(scene, camera);
			}

			const originalMaterials = {};

			function highlightLayer(parentObject, layerName) {
				parentObject.traverse((child) => {
					if (child.name === layerName && child.material) {
						if (!originalMaterials[layerName]) {
							// Store the original material only if it hasn't been stored yet
							originalMaterials[layerName] = child.material;
						}
						const newMaterial = child.material.clone();
						newMaterial.color.setHex(0xffffff); // Highlight color: white
						child.material = newMaterial;
					}
				});
			}

			function resetLayerColor(parentObject, layerName) {
				if (originalMaterials[layerName]) {
					parentObject.traverse((child) => {
						if (child.name === layerName && child.material) {
							// Reset the material to the original
							child.material = originalMaterials[layerName];
						}
					});
				}
			}


			function showOnlyLayer(parentObject, layerName) {
				parentObject.traverse((child) => {
					// Check if the child is a layer that should be shown or hidden
					if (child.name === layerName) {
						child.visible = true; // Show only the matching layer
					} else {
						// Check if this child is another layer to ensure we're not hiding non-layer objects
						if (child.name.startsWith('layer')) {
							child.visible = false; // Hide all other layers
						}
					}
				});
			}

			function performRaycasting() {
				raycaster.setFromCamera(mouse, camera);
				const intersects = raycaster.intersectObjects(scene.children, true);

				if (intersects.length > 0) {
					const intersectedLayerName = intersects[0].object.name; // Determine layer name
					
					if (currentHoverLayer !== intersectedLayerName) {
						// Reset previous layer if it's different from the current
						if (currentHoverLayer) {
							resetLayerColor(scene, currentHoverLayer);
						}
						highlightLayer(scene, intersectedLayerName);
						currentHoverLayer = intersectedLayerName;
					}
				} else if (currentHoverLayer) {
					// If nothing is intersected, reset the last hovered layer
					resetLayerColor(scene, currentHoverLayer);
					currentHoverLayer = null;
				}
			}


			function render() {
				renderer.render( scene, camera );

			}


		</script>

	<!-- Code injected by live-server -->
<script>
	// <![CDATA[  <-- For SVG support
	if ('WebSocket' in window) {
		(function () {
			function refreshCSS() {
				var sheets = [].slice.call(document.getElementsByTagName("link"));
				var head = document.getElementsByTagName("head")[0];
				for (var i = 0; i < sheets.length; ++i) {
					var elem = sheets[i];
					var parent = elem.parentElement || head;
					parent.removeChild(elem);
					var rel = elem.rel;
					if (elem.href && typeof rel != "string" || rel.length == 0 || rel.toLowerCase() == "stylesheet") {
						var url = elem.href.replace(/(&|\?)_cacheOverride=\d+/, '');
						elem.href = url + (url.indexOf('?') >= 0 ? '&' : '?') + '_cacheOverride=' + (new Date().valueOf());
					}
					parent.appendChild(elem);
				}
			}
			var protocol = window.location.protocol === 'http:' ? 'ws://' : 'wss://';
			var address = protocol + window.location.host + window.location.pathname + '/ws';
			var socket = new WebSocket(address);
			socket.onmessage = function (msg) {
				if (msg.data == 'reload') window.location.reload();
				else if (msg.data == 'refreshcss') refreshCSS();
			};
			if (sessionStorage && !sessionStorage.getItem('IsThisFirstTime_Log_From_LiveServer')) {
				console.log('Live reload enabled.');
				sessionStorage.setItem('IsThisFirstTime_Log_From_LiveServer', true);
			}
		})();
	}
	else {
		console.error('Upgrade your browser. This Browser is NOT supported WebSocket for Live-Reloading.');
	}
	// ]]>
</script>
</body>
</html>
